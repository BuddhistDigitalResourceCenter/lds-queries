#QueryScope=Etexts
#QueryReturnType=Graph
#QueryResults=A graph containing the chunks within the given limits for the given Resource
#QueryParams=R_RES,I_SEQ,I_LIM
#QueryUrl=/Chunks?R_RES=bdr:UT4CZ5369_I1KG9127_0000&I_LIM=9&I_SEQ=1

#param.R_RES.type=resource
#param.R_RES.subtype=a Resource ID
#param.R_RES.desc=the unique resource ID of the Etext being searched

#param.I_SEQ.type=int
#param.I_SEQ.desc=the index (sequence number) of the first chunk to be fetched

#param.I_LIM.type=int
#param.I_LIM.desc=the maximum number of chunks returned

construct {
  ?R_RES bdo:eTextHasChunk ?chunk .
  ?chunk ?p ?o .
  ?R_RES :eTextHasPage ?page .
  ?page ?pageP ?pageO .
  ?line ?lineP ?lineO .
  # annotations on these chunks
  ?R_RES tmp:hasAnno ?anno .
  ?R_RES tmp:hasAnnoAnno ?aAnno .
}
where {
  {
    ?R_RES bdo:eTextHasChunk ?chunk .
    ?chunk bdo:seqNum ?seqNum .
    BIND((?I_SEQ + ?I_LIM) AS ?max).
    filter (?seqNum >= ?I_SEQ && ?seqNum < ?max)
    ?chunk ?p ?o .
  } union {
    ?R_RES :eTextHasPage ?page .
    ?page :sliceStartChunk ?chunkNum .
    {
      # fetch max chunk values (needs to be in a subquery, at least I couldn't find any other way)
      select (max(?endChunksub) as ?endChunkMax) (min(?startChunksub) as ?startChunkMin) where {
        ?R_RES bdo:eTextHasChunk ?chunksub .
        ?chunksub bdo:seqNum ?seqNumsub .
        BIND((?I_SEQ + ?I_LIM) AS ?max).
        filter (?seqNumsub >= ?I_SEQ && ?seqNumsub < ?max)
        ?chunksub
         :sliceStartChunk ?startChunksub ;
         :sliceEndChunk ?endChunksub .
      }
    }
    filter (?chunkNum>=?startChunkMin && ?chunkNum<?endChunkMax)
    ?page ?pageP ?pageO .
    optional {
      ?page :pageHasLine ?line .
      ?line ?lineP ?lineO .
    }
  } union {
      # annotations that targets... this etext
      ?R_RES :etextForVolume/:volumeOf/:itemEtextForWork ?aWork .
      ?anno oa:hasTarget/:workLocationWork ?aWork .
      # ... this volume
      ?aWork :workHasItemEtext/:itemHasVolume ?iVol .
      ?iVol :volumeHasEtext ?R_RES .
      ?iVol :volumeNumber ?aVol .
      ?anno oa:hasTarget/:workLocationVolume ?aVol .
      # ... one of these chunks
      ?anno oa:hasTarget/:workLocationChar ?aStartC .
      ?anno oa:hasTarget/:workLocationEndChar ?aEndC .
      {
         # subquery to get character range of current chunks (inspired from above)
         select (min(?cStartC) as ?minC) (max(?cEndC) as ?maxC)
         where {
           ?R_RES bdo:eTextHasChunk ?chunksub .
           ?chunksub bdo:seqNum ?seqNum .
           BIND((?I_SEQ + ?I_LIM) AS ?max).
           filter (?seqNum >= ?I_SEQ && ?seqNum < ?max) .
           ?chunksub
               :sliceStartChar ?cStartC ;
               :sliceEndChar ?cEndC .
         }
      }
      filter( ( ?aStartC >= ?minC && ?aStartC <= ?maxC ) || ( ?aEndC >= ?minC && ?aEndC <= ?maxC ) )

      # (annotations that targets)+ these annotations
      optional {
         ?aAnno oa:hasTarget+ ?anno
      }
  }
}
