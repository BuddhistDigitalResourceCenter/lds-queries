#QueryScope=Etexts
#QueryReturnType=Graph
#QueryResults=A graph containing the chunks within the given limits for the given Resource
#QueryParams=R_RES,I_SEQ,I_LIM
#QueryUrl=/Chunks?R_RES=bdr:UT4CZ5369_I1KG9127_0000&I_LIM=9&I_SEQ=1

#param.R_RES.type=resource
#param.R_RES.subtype=a Resource ID
#param.R_RES.desc=the unique resource ID of the Etext being searched

#param.I_SEQ.type=int
#param.I_SEQ.desc=the index (sequence number) of the first chunk to be fetched

#param.I_LIM.type=int
#param.I_LIM.desc=the maximum number of chunks returned

construct {
  ?R_RES bdo:eTextHasChunk ?chunk .
  ?chunk ?p ?o .
  ?R_RES :eTextHasPage ?page .
  ?page ?pageP ?pageO .
  ?line ?lineP ?lineO .
}
where {
  {
    ?R_RES bdo:eTextHasChunk ?chunk .
    ?chunk bdo:seqNum ?seqNum .
    BIND((?I_SEQ + ?I_LIM) AS ?max).
    filter (?seqNum >= ?I_SEQ && ?seqNum < ?max)
    ?chunk ?p ?o .
  } union {
    ?R_RES :eTextHasPage ?page .
    ?page :sliceStartChunk ?chunkNum .
    {
      # fetch max chunk values (needs to be in a subquery, at least I couldn't find any other way)
      select (max(?endChunksub) as ?endChunkMax) (min(?startChunksub) as ?startChunkMin) where {
        ?R_RES bdo:eTextHasChunk ?chunksub .
        ?chunksub bdo:seqNum ?seqNumsub .
        BIND((?I_SEQ + ?I_LIM) AS ?max).
        filter (?seqNumsub >= ?I_SEQ && ?seqNumsub < ?max)
        ?chunksub
         :sliceStartChunk ?startChunksub ;
         :sliceEndChunk ?endChunksub .
      }
    }
    filter (?chunkNum>=?startChunkMin && ?chunkNum<?endChunkMax)
    ?page ?pageP ?pageO .
    optional {
      ?page :pageHasLine ?line .
      ?line ?lineP ?lineO .
    }
  }
}
